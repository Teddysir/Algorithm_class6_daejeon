# 문제 제목

## 📋 문제 정보
- **플랫폼**: SWEA
- **문제 번호**: 3307
- **난이도**: D3

---

## 🎯 문제 접근 방식

- **문제 분석 :**
최장길이 수열 같은 경우 Ai <= A <= Ak 의 조건이 만족하는 상태에서 가장 큰 길이를 찾는 문제입니다.

- **사용할 알고리즘/자료구조 :**
사실 이건 우성 센세의 조언이 많이 반영된 문제라 저의 실패담을 알려드리겠습니다.
이중 for문 그리디 방식
뒷값을 고정한 상태에서 왼쪽에서부터 차례차례 수열 조건을 한 상태에서 카운팅을 했습니다.
past < now < next.value 와 같은 조건을 만족할대 수의 숫자를 세서 max 를 통해 최댓값을 구하려고 유도했지만 이렇게 된 방식은 1792345 일때 179 만 도출 하게 되어서 틀린 방식이었습니다.

dfs + 가지치기를 곁들인 (하지만 시간복잡도 부터 2^1000 이기 때문에 불가능)
앞선 그리디 방식 같은 경우 해당 수를 고를때, 고르지 않을때의 경우의 수가 안나뉘기 때문에 이점을 반영하여 dfs로 접근했습니다. 
시간복잡도가 넘어갈 것 같았는데 그래도 가지치기 곁들이면 괜찮지 않을까? 하고접근했는데 아우 어림 없었습니다. 
아직 시간복잡도 구하는 방법이 미흡해서 저에게 이점을 보완해야할 것 같습니다.

binaysearch 방법 이용 (+우성이형님 정말 감사합니다)
정렬된 배열에서 인자값의 index를 구하는 기능인데 값이 없을 경우 원래 있던 값의 좌표 기준 의 음수값을 반환합니다.
이 점을 이용해서 수열의 내용은 바뀔 수 있지만 길이 값은 동일 하기 때문에 최댓값 산출이 가능합니다. (앞 값은 어차피 정렬된 배열이기 때문에 작다라는 것이 보장되어 있고 a <= k 의 조건을 만족하고 최소값(다음 값도 와야하기 때문에 뒤의값이 mid 값이 될 수 있으므로 조건을 만족하되 최소값을 유지하므로 길이는 위배되지 않다?라고 해석했습니다.))

---

## 📊 복잡도 분석

- **O(nlogn)**
- 전체 배열을 검사하는 반복문 n * binarysearch 기능 (이분탐색 원리 log n)

---

## ⚡ 메모리/실행시간

### 결과
- **메모리**: 19,440KB
- **실행시간**: 103ms

### 기타 및 참고사항
https://hongs-coding.tistory.com/19
