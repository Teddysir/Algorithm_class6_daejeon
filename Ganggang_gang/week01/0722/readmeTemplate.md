# 문제 제목

## 📋 문제 정보
- **플랫폼**: SWEA
- **문제 번호**: 3282.
- **난이도**: 오랜만에 DP 보느라 굉장히 힘들었습니다.

---

## 🎯 문제 접근 방식

- **문제 분석 :**
가방 무게와 value의 적절한 모든 경우의 수를 구하는게 중요하다고 생각했습니다.
무게가 낮지만 value가 낮아 최적의 수를 포기할 수 있으니 greedy알고리즘 혹은
시간복잡도로 인하여 dfs 방법은 안먹힙니다. (백트래킹과 프러닝(가지치기))이용해서 모두 구해봤는데 다 시간초과였습니다.
dp 방식을 채택했습니다.

- **사용할 알고리즘/자료구조 :**
DP
먼저 각 무게와 value를 배열을 따로 구했습니다.
그리고 dp 테이블 같은 경우에는 행은 n(아이템의 개수? 보다는 입력된 가짓수의 진행 상황) 열은 k(무게)로 잡았습니다.
처음에는 오름차순으로 dp 방식을 고민했는데 생각해보니깐 어차피 두가지 경우의수 짐을 고르냐 안고르냐의 차이이고 각 케이스별을 봐야하기때문에 정렬은 필요없다고 생각했습니다.

고안을 많이 한 케이스는 가치 테이블 말고 무게 테이블을 어떻게 처리할 지 였습니다.
두번째 for 문 j=1 j<=k 에서 j는 포용할 수 있는 가방 용량이라고 생각했습니다.
즉 포용할 수 있는 가방 상태(j 열) 과 들어 가 있는 아이템 수 현황(i 행)을 고려하여 최댓값을 도출하는 2차원 배열 dp를 유도하게 되었습니다.

---

## 📊 복잡도 분석

- **O(n*k)**
- 이유: dp 할때 아이템 수가 n 이고 가방수를 k 라고 할때 이중 포문으로 n*k 라고 생각했습니다.

---

## ⚡ 메모리/실행시간

### 결과
- **메모리**: 31,532KB
- **실행시간**: 104ms

### 기타 및 참고사항
https://www.youtube.com/watch?v=0bqfTzpWySY&t=1s
